# multiple targets

This is an example / research project in which I want to look how to
best achieve the following with CMake / nix:

 - Compile a library / framework for different targets

 - Add a linkerscript to the "INTERFACE" properties of a static
   library; allow it to be installed

 - Automatically set the target for an exectuable using the library /
   framework
   
   - approach 1: using a custom script which sets a toolchain file or
     similar
     
   - approach 2: using CMake to re-execute itself
   

This project contains a library / framework which is expected to be
linked with user code.  The library / framework contains startup code
(`main` so to say) while the user code does only provide a special
function `CallApplication()`.

 - Framework / library `mutliple::lib` (`liblib.a`)
   - contains startup code (`main` for hosted)
   - calls `CallApplication()`
 - User code (example in `./test`)
   - contains `CallApplication()` function

   

# The linkerscript

Adding a linker script is as easy as adding `-T path/to/script.ld` to
`LDFLAGS`.  At least that's what you'd think.  The critical thing is
... what is `path/to/`?  During build that's easy: just use a path in
the source directory.  But what about an installed library which
distributes that linker script with it? (So when you link against the
lib you're supposed to `ld ... -lthe_lib -T where/is/that/script.ld`)

~~~cmake
target_link_options(lib INTERFACE -T
  $<BUILD_INTERFACE: link.ld>)
  $<INSTALL_INTERFACE: share/link.ld>)
install(FILES link.ld
  DESTINATION share/)
~~~

The above works ... it says that anyone linking to lib (using the
exported target after installing) needs to specify ...

~~~
-T "${CMAKE_INSTALL_PREFIX}/share/link.ld"
~~~

... which correctly points to the linker script *once it is **really**
installed*.  See the problem?

Normally CMake is pretty clever with all that EXPORT stuff when
installing ... it uses relative paths.  So in general you can do

~~~bash
cd lib-build
cmake path/lib/srcs -DCMAKE_INSTALL_PREFIX=""; make; DESTDIR=../stage install
# this created ../stage/lib/cmake/lib/libConfig.cmake and friends
cd ..

cd test-build
cmake path/test/srcs -Dlib_DIR=../stage/lib/cmake/lib;
make # uses stuff from ../stage
~~~

But the above absolute path to the linker script *breaks* this;
because the script is not in `/share/link.ld` but in
`../stage/share/link.ld` as it's not (yet) installed.

Fixing this can be done like in this project:

~~~cmake
# Only for build time
target_link_options(lib INTERFACE
  $<BUILD_INTERFACE: -T link.ld>)
# install linker script
install(FILES link.ld
  DESTINATION share/)
# install "install time config"
install(FILES libTargets-someName.cmake
  DESTINATION lib/cmake/lib)
~~~

With a `libTargets-someName.cmake` with:

~~~cmake
target_link_options(lib::lib
  INTERFACE
  -T ${_IMPORT_PREFIX}/share/link.ld)
~~~

Which uses `${_IMPORT_PREFIX}` which is create by CMake itself in
`lib/cmake/lib/libTargets.cmake` (generated by an install EXPORT
call).
